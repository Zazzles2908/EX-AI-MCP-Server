<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EXAI MCP Server - Real-Time Monitoring</title>
    <!-- PHASE 1 REFACTORING (2025-10-23): External CSS -->
    <link rel="stylesheet" href="/static/css/dashboard.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- PHASE 2 REFACTORING (2025-10-23): External JavaScript modules -->
    <script src="/static/js/websocket-client.js"></script>
    <script src="/static/js/dashboard-core.js"></script>
    <script src="/static/js/chart-manager.js"></script>
    <script src="/static/js/session-tracker.js"></script>
    <!-- PHASE 0.1 (2025-10-24): AI Auditor Panel -->
    <script src="/static/js/auditor-panel.js"></script>
    <!-- PHASE 0.4 (2025-10-24): Testing Panel -->
    <script src="/static/js/testing-panel.js"></script>
    <!-- PHASE 1 REFACTORING (2025-10-23): CSS extracted to /static/css/dashboard.css (290 lines removed) -->
</head>
<body>
    <div class="header">
        <h1>🚀 EXAI MCP Server</h1>
        <div class="subtitle">Real-Time System Monitoring Dashboard</div>
        <div class="connection-status" id="connectionStatus">Connecting...</div>
    </div>

    <!-- TIER 1: System Health Bar -->
    <div class="health-bar">
        <div class="health-indicator" id="systemHealth">
            <div class="health-score" id="healthScore">--</div>
            <div class="health-label">System Health</div>
            <div class="health-details" id="healthDetails">Calculating...</div>
        </div>
        <div class="health-indicator">
            <div class="health-score" id="throughputScore">0</div>
            <div class="health-label">Throughput</div>
            <div class="health-details">req/s</div>
        </div>
        <div class="health-indicator">
            <div class="health-score" id="connectionsScore">0</div>
            <div class="health-label">Connections</div>
            <div class="health-details" id="connectionsDetails">Active</div>
        </div>
        <div class="health-indicator">
            <div class="health-score" id="errorRateScore">0%</div>
            <div class="health-label">Error Rate</div>
            <div class="health-details" id="errorRateDetails">Normal</div>
        </div>
        <div class="health-indicator">
            <div class="health-score" id="responseTimeScore">--</div>
            <div class="health-label">Response (p95)</div>
            <div class="health-details">ms</div>
        </div>
    </div>

    <!-- PHASE 3.4 (2025-10-23): Session & Conversation Metrics Panel -->
    <div class="session-metrics-panel" id="sessionMetricsPanel">
        <div class="session-metric">
            <div class="session-metric-icon">👥</div>
            <div class="session-metric-content">
                <div class="session-metric-label">Active Sessions</div>
                <div class="session-metric-value" id="activeSessionsValue">0</div>
            </div>
        </div>
        <div class="session-metric">
            <div class="session-metric-icon">💬</div>
            <div class="session-metric-content">
                <div class="session-metric-label">Conversation Length</div>
                <div class="session-metric-value" id="conversationLengthValue">-- messages</div>
            </div>
        </div>
        <div class="session-metric">
            <div class="session-metric-icon">🧠</div>
            <div class="session-metric-content">
                <div class="session-metric-label">Context Window</div>
                <div class="session-metric-value" id="contextWindowValue">-- / --</div>
            </div>
        </div>
        <div class="session-metric">
            <div class="session-metric-icon">🤖</div>
            <div class="session-metric-content">
                <div class="session-metric-label">Current Model</div>
                <div class="session-metric-value" id="currentModelValue">--</div>
            </div>
        </div>
    </div>

    <!-- AI AUDITOR PANEL (2025-10-24): Real-time AI observations -->
    <div class="auditor-section" id="auditorSection">
        <div class="auditor-header">
            <h2>🤖 AI Auditor Insights</h2>
            <div class="auditor-controls">
                <select id="severityFilter" onchange="filterObservations()">
                    <option value="all">All Severity</option>
                    <option value="critical">Critical Only</option>
                    <option value="warning">Warnings+</option>
                    <option value="info">All Insights</option>
                </select>
                <select id="categoryFilter" onchange="filterObservations()">
                    <option value="all">All Categories</option>
                    <option value="performance">Performance</option>
                    <option value="security">Security</option>
                    <option value="reliability">Reliability</option>
                    <option value="quality">Quality</option>
                    <option value="general">General</option>
                </select>
                <button onclick="acknowledgeAllObservations()">✓ Acknowledge All</button>
            </div>
        </div>
        <div id="auditorObservations" class="observations-list">
            <div class="no-observations">No observations yet. AI Auditor is watching...</div>
        </div>
    </div>

    <!-- PHASE 0.4 (2025-10-24): Testing-Specific Panels -->
    <div class="testing-section" id="testingSection" style="display: none;">
        <div class="testing-header">
            <h2>🧪 Testing Dashboard</h2>
            <div class="testing-controls">
                <button onclick="toggleTestingMode()" id="testingModeToggle">Enable Testing Mode</button>
                <button onclick="captureBaseline()">📸 Capture Baseline</button>
                <button onclick="compareToBaseline()">📊 Compare to Baseline</button>
            </div>
        </div>

        <!-- Test Execution Status -->
        <div class="test-panel">
            <h3>Test Execution Status</h3>
            <div id="testExecutionStatus" class="test-status-grid">
                <div class="test-stat">
                    <div class="test-stat-label">Tests Running</div>
                    <div class="test-stat-value" id="testsRunning">0</div>
                </div>
                <div class="test-stat">
                    <div class="test-stat-label">Tests Passed</div>
                    <div class="test-stat-value success" id="testsPassed">0</div>
                </div>
                <div class="test-stat">
                    <div class="test-stat-label">Tests Failed</div>
                    <div class="test-stat-value error" id="testsFailed">0</div>
                </div>
                <div class="test-stat">
                    <div class="test-stat-label">Success Rate</div>
                    <div class="test-stat-value" id="testSuccessRate">--</div>
                </div>
            </div>
        </div>

        <!-- Baseline Comparison -->
        <div class="test-panel">
            <h3>Baseline Comparison</h3>
            <div id="baselineComparison" class="baseline-grid">
                <div class="baseline-metric">
                    <div class="baseline-label">Latency (p95)</div>
                    <div class="baseline-current" id="currentLatency">--</div>
                    <div class="baseline-delta" id="latencyDelta">--</div>
                    <div class="baseline-baseline" id="baselineLatency">Baseline: --</div>
                </div>
                <div class="baseline-metric">
                    <div class="baseline-label">Memory Usage</div>
                    <div class="baseline-current" id="currentMemory">--</div>
                    <div class="baseline-delta" id="memoryDelta">--</div>
                    <div class="baseline-baseline" id="baselineMemory">Baseline: --</div>
                </div>
                <div class="baseline-metric">
                    <div class="baseline-label">Success Rate</div>
                    <div class="baseline-current" id="currentSuccess">--</div>
                    <div class="baseline-delta" id="successDelta">--</div>
                    <div class="baseline-baseline" id="baselineSuccess">Baseline: --</div>
                </div>
            </div>
        </div>

        <!-- Performance Regression Detection -->
        <div class="test-panel">
            <h3>Performance Regression Detection</h3>
            <div id="regressionDetection" class="regression-list">
                <div class="no-regressions">No regressions detected</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button onclick="refreshStats()">🔄 Refresh Stats</button>
        <button onclick="exportData()">💾 Export Data</button>
        <button onclick="clearEvents()">🗑️ Clear Events</button>
    </div>
    
    <div class="dashboard-grid">
        <div class="card">
            <h2>WebSocket</h2>
            <div id="websocketStats"></div>
        </div>
        
        <div class="card">
            <h2>Redis</h2>
            <div id="redisStats"></div>
        </div>
        
        <div class="card">
            <h2>Supabase</h2>
            <div id="supabaseStats"></div>
        </div>
        
        <div class="card">
            <h2>Kimi API</h2>
            <div id="kimiStats"></div>
        </div>
        
        <div class="card">
            <h2>GLM API</h2>
            <div id="glmStats"></div>
        </div>
    </div>
    
    <!-- TIER 2: Time-Series Charts -->
    <div class="chart-grid">
        <div class="chart-card">
            <h3>📊 Events Over Time</h3>
            <div class="chart-container">
                <canvas id="eventsChart"></canvas>
            </div>
        </div>
        <div class="chart-card">
            <h3>⚡ Response Times</h3>
            <div class="chart-container">
                <canvas id="responseChart"></canvas>
            </div>
        </div>
        <div class="chart-card">
            <h3>🚀 Throughput</h3>
            <div class="chart-container">
                <canvas id="throughputChart"></canvas>
            </div>
        </div>
        <div class="chart-card">
            <h3>❌ Error Rates</h3>
            <div class="chart-container">
                <canvas id="errorChart"></canvas>
            </div>
        </div>
    </div>
    
    <div class="event-log">
        <h2 style="color: #667eea; margin-bottom: 15px;">Recent Events</h2>
        <div id="eventLog"></div>
    </div>
    
    <script>
        // PHASE 2 REFACTORING (2025-10-23): Use modular architecture
        let wsClient = null;
        let dashboard = null;

        // Legacy compatibility - expose events array for existing code
        let events = [];
        let statsData = {};

        // Chart instances (PHASE 3.1: Make global for debugging)
        window.charts = {
            events: null,
            response: null,
            throughput: null,
            error: null
        };
        const charts = window.charts; // Local reference for convenience

        // Data buffers for charts
        const chartData = {
            events: { labels: [], datasets: [] },
            response: { labels: [], datasets: [] },
            throughput: { labels: [], datasets: [] },
            error: { labels: [], datasets: [] }
        };

        // Service colors (matching EXAI recommendations)
        const serviceColors = {
            websocket: '#3B82F6',  // Blue
            redis: '#EF4444',       // Red
            supabase: '#10B981',    // Green
            kimi: '#8B5CF6',        // Purple
            glm: '#F59E0B'          // Orange
        };

        // PHASE 2 REFACTORING (2025-10-23): Initialize chart manager and session tracker
        let chartManager = null;
        let sessionTracker = null;

        // Health tracking
        let healthData = {
            websocket: { status: 'unknown', score: 0 },
            redis: { status: 'unknown', score: 0 },
            supabase: { status: 'unknown', score: 0 },
            kimi: { status: 'unknown', score: 0 },
            glm: { status: 'unknown', score: 0 }
        };
        
        // PHASE 2 REFACTORING (2025-10-23): Initialize WebSocket client with new module
        function initializeWebSocket() {
            const wsUrl = 'ws://localhost:8080/ws';

            wsClient = new WebSocketClient(wsUrl, {
                onopen: () => {
                    console.log('Connected to monitoring server');
                    dashboard.setConnected(true);
                },
                onmessage: (data) => {
                    handleMessage(data);
                },
                onerror: (error) => {
                    console.error('WebSocket error:', error);
                },
                onclose: (event) => {
                    console.log('Disconnected from monitoring server');
                    dashboard.setConnected(false);
                },
                onreconnect: (attempt) => {
                    console.log(`Reconnection attempt ${attempt}...`);
                },
                reconnectDelay: 5000,
                maxReconnectDelay: 30000,
                reconnectBackoffMultiplier: 1.5
            });

            wsClient.connect();
        }
        
        function handleMessage(data) {
            if (data.type === 'initial_stats') {
                updateAllStats(data.stats);
                data.recent_events.forEach(e => addEvent(e));
                // PHASE 3.5 (2025-10-23): Update session metrics from backend
                if (data.session_metrics) {
                    updateSessionMetrics(data.session_metrics);
                }
                // PHASE 3.1 (2025-10-23): Request historical data after initial stats
                loadHistoricalData();
            } else if (data.type === 'session_metrics') {
                // PHASE 3.5 (2025-10-23): Handle session metrics updates
                if (data.data) {
                    updateSessionMetrics(data.data);
                }
            } else if (data.type === 'event') {
                addEvent(data);
                // Update stats for this connection type
                refreshStatsFor(data.connection_type);
                // PHASE 3.1 (2025-10-23): Buffer event for chart updates
                bufferEventForCharts(data);
            } else if (data.type === 'stats') {
                updateStats(data.connection_type, data.stats);
            } else if (data.type === 'historical_data') {
                // PHASE 3.1 (2025-10-23): Handle historical data response
                console.log('[CHARTS] Received historical data:', data.data?.length || 0, 'events');
                populateChartsWithHistoricalData(data.data);
            }
        }
        
        function updateAllStats(stats) {
            dashboard.updateAllStats(stats);
            updateHealthBar(); // PHASE 3.3 (2025-10-23): Update health bar when stats change
        }

        function updateStats(type, stats) {
            const containerId = type + 'Stats';
            const container = document.getElementById(containerId);
            if (!container || !stats) return;

            container.innerHTML = `
                <div class="metric">
                    <span class="metric-label">Total Events</span>
                    <span class="metric-value">${stats.total_events || 0}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Errors</span>
                    <span class="metric-value ${stats.error_count > 0 ? 'error' : ''}">${stats.error_count || 0}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Avg Response Time</span>
                    <span class="metric-value">${stats.avg_response_time_ms ? stats.avg_response_time_ms.toFixed(2) + ' ms' : 'N/A'}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Data</span>
                    <span class="metric-value">${formatBytes(stats.total_bytes || 0)}</span>
                </div>
            `;

            // Update health data for this service
            updateServiceHealth(type, stats);
        }
        
        // PHASE 2 REFACTORING (2025-10-23): Helper to parse event timestamps
        function getEventTimestamp(event) {
            // Real-time events have broadcast_time as string (e.g., "2025-10-23 15:11:01 AEDT")
            // Historical events have timestamp as Unix seconds
            if (event.broadcast_time) {
                // Parse "YYYY-MM-DD HH:MM:SS TIMEZONE" format
                // Remove timezone suffix and parse as local time
                const timeStr = event.broadcast_time.replace(/ [A-Z]+$/, '');
                const parsed = new Date(timeStr);
                if (!isNaN(parsed.getTime())) {
                    return parsed.getTime();
                }
            } else if (event.timestamp) {
                return event.timestamp * 1000; // Convert Unix seconds to milliseconds
            }
            return Date.now(); // Fallback to current time
        }

        function addEvent(event) {
            dashboard.addEvent(event);
        }

        function renderEvents() {
            const logEl = document.getElementById('eventLog');
            logEl.innerHTML = events.map(e => {
                const timestamp = getEventTimestamp(e);
                const dateStr = new Date(timestamp).toLocaleString();
                return `
                    <div class="event-item ${e.error ? 'error' : ''}">
                        <div class="event-time">${dateStr}</div>
                        <div class="event-details">
                            <strong>${e.connection_type}</strong> - ${e.direction} - ${e.function_name}
                            ${e.error ? `<br><span style="color: #ef4444;">Error: ${e.error}</span>` : ''}
                            ${e.response_time_ms ? `<br>Response: ${e.response_time_ms.toFixed(2)} ms` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function refreshStats() {
            if (wsClient && wsClient.isReady()) {
                wsClient.send({ command: 'get_stats' });
            }
        }

        function refreshStatsFor(type) {
            if (wsClient && wsClient.isReady()) {
                wsClient.send({ command: 'get_stats', connection_type: type });
            }
        }

        function exportData() {
            if (wsClient && wsClient.isReady()) {
                wsClient.send({ command: 'export', filepath: 'monitoring_export.json' });
                alert('Export requested! Check server logs for file location.');
            }
        }

        function clearEvents() {
            dashboard.clearEvents();
        }

        // Initialize charts
        // PHASE 2 REFACTORING (2025-10-23): Use ChartManager for chart initialization
        function initializeCharts() {
            chartManager = new ChartManager(serviceColors);
            return chartManager.initializeCharts();
        }

        // Calculate system health
        function calculateSystemHealth() {
            const weights = {
                websocket: 0.2,
                redis: 0.2,
                supabase: 0.2,
                kimi: 0.2,
                glm: 0.2
            };

            let totalScore = 0;
            let criticalCount = 0;
            let degradedCount = 0;

            for (const [service, weight] of Object.entries(weights)) {
                const data = healthData[service];
                if (data.status === 'critical') criticalCount++;
                if (data.status === 'degraded') degradedCount++;
                totalScore += data.score * weight;
            }

            const healthScore = Math.round(totalScore);
            let status = 'healthy';
            let statusClass = 'healthy';

            if (criticalCount > 0 || healthScore < 70) {
                status = 'critical';
                statusClass = 'critical';
            } else if (degradedCount > 0 || healthScore < 90) {
                status = 'degraded';
                statusClass = 'degraded';
            }

            // Update UI
            const healthIndicator = document.getElementById('systemHealth');
            const healthScoreEl = document.getElementById('healthScore');
            const healthDetailsEl = document.getElementById('healthDetails');

            healthIndicator.className = `health-indicator ${statusClass}`;
            healthScoreEl.className = `health-score ${statusClass}`;
            healthScoreEl.textContent = healthScore + '%';
            healthDetailsEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }

        // Update health data for a service
        function updateServiceHealth(service, stats) {
            if (!stats) return;

            const errorRate = stats.total_events > 0 ? (stats.error_count / stats.total_events) * 100 : 0;
            const avgResponseTime = stats.avg_response_time_ms || 0;

            let score = 100;
            let status = 'healthy';

            // Deduct points for errors
            if (errorRate > 5) {
                score -= 40;
                status = 'critical';
            } else if (errorRate > 1) {
                score -= 20;
                status = 'degraded';
            }

            // Deduct points for slow response times
            if (avgResponseTime > 500) {
                score -= 30;
                if (status !== 'critical') status = 'degraded';
            } else if (avgResponseTime > 200) {
                score -= 10;
            }

            healthData[service] = { status, score: Math.max(0, score) };
            calculateSystemHealth();
            updateHealthBar(); // PHASE 3.3 (2025-10-23): Update health bar after recalculation
        }

        // PHASE 2 REFACTORING (2025-10-23): Use SessionTracker for session metrics
        function updateSessionMetrics(metrics) {
            if (!metrics) return;

            // Map backend field names to session tracker field names
            const mappedMetrics = {
                active_sessions: metrics.active_sessions,
                conversation_length: metrics.conversation_length,
                context_tokens_used: metrics.context_tokens_used,
                context_tokens_max: metrics.context_tokens_max,
                current_model: metrics.current_model
            };

            // Update session tracker (handles UI updates and color coding)
            sessionTracker.updateMetrics(mappedMetrics);

            // Also update dashboard core for event emission
            dashboard.updateSessionMetrics({
                active_sessions: metrics.active_sessions,
                conversation_length: metrics.conversation_length,
                tokens_used: metrics.context_tokens_used,
                max_tokens: metrics.context_tokens_max,
                current_model: metrics.current_model
            });
        }

        // PHASE 3.3 (2025-10-23): Update health bar with real-time metrics
        function updateHealthBar() {
            // Calculate overall health score
            const services = Object.keys(healthData);
            if (services.length === 0) return;

            const totalScore = services.reduce((sum, service) => sum + healthData[service].score, 0);
            const healthScore = Math.round(totalScore / services.length);

            // Update System Health
            const healthScoreEl = document.getElementById('healthScore');
            const healthDetailsEl = document.getElementById('healthDetails');
            healthScoreEl.textContent = `${healthScore}%`;

            if (healthScore >= 90) {
                healthDetailsEl.textContent = 'Healthy';
                healthDetailsEl.style.color = '#10b981';
            } else if (healthScore >= 70) {
                healthDetailsEl.textContent = 'Degraded';
                healthDetailsEl.style.color = '#f59e0b';
            } else {
                healthDetailsEl.textContent = 'Critical';
                healthDetailsEl.style.color = '#ef4444';
            }

            // Calculate and update Throughput (events per second over last minute)
            // PHASE 2 REFACTORING (2025-10-23): Use getEventTimestamp helper for both real-time and historical events
            const now = Date.now();
            const oneMinuteAgo = now - 60000;
            const recentEvents = events.filter(e => {
                const eventTime = getEventTimestamp(e);
                return eventTime >= oneMinuteAgo;
            });
            const throughput = (recentEvents.length / 60).toFixed(2);
            document.getElementById('throughputScore').textContent = throughput;

            // Update Connections (count active WebSocket connections)
            // PHASE 2 REFACTORING (2025-10-23): Use wsClient instead of ws
            const connected = wsClient && wsClient.isReady();
            document.getElementById('connectionsScore').textContent = connected ? '1' : '0';

            // Calculate and update Error Rate
            const totalEvents = Object.values(statsData).reduce((sum, s) => sum + (s.total_events || 0), 0);
            const totalErrors = Object.values(statsData).reduce((sum, s) => sum + (s.error_count || 0), 0);
            const errorRate = totalEvents > 0 ? ((totalErrors / totalEvents) * 100).toFixed(1) : 0;
            document.getElementById('errorRateScore').textContent = `${errorRate}%`;

            const errorDetailsEl = document.getElementById('errorRateDetails');
            if (errorRate > 5) {
                errorDetailsEl.textContent = 'Critical';
                errorDetailsEl.style.color = '#ef4444';
            } else if (errorRate > 1) {
                errorDetailsEl.textContent = 'Warning';
                errorDetailsEl.style.color = '#f59e0b';
            } else {
                errorDetailsEl.textContent = 'Normal';
                errorDetailsEl.style.color = '#10b981';
            }

            // Calculate and update Response Time (p95)
            const allResponseTimes = [];
            Object.values(statsData).forEach(s => {
                if (s.avg_response_time_ms) {
                    allResponseTimes.push(s.avg_response_time_ms);
                }
            });

            if (allResponseTimes.length > 0) {
                allResponseTimes.sort((a, b) => a - b);
                const p95Index = Math.floor(allResponseTimes.length * 0.95);
                const p95 = allResponseTimes[p95Index] || allResponseTimes[allResponseTimes.length - 1];
                document.getElementById('responseTimeScore').textContent = `${p95.toFixed(0)}`;
            }
        }

        // PHASE 3.1 (2025-10-23): Chart data population and real-time updates
        const eventBuffer = [];
        let lastChartUpdate = Date.now();
        const CHART_UPDATE_INTERVAL = 1000; // 1 second
        const MAX_CHART_POINTS = 60; // Keep last 60 data points (1 hour at 1-minute intervals)

        // Request historical data on dashboard load
        // PHASE 2 REFACTORING (2025-10-23): Use wsClient instead of ws
        function loadHistoricalData() {
            if (!wsClient || !wsClient.isReady()) {
                console.log('[CHARTS] WebSocket not ready, retrying in 1s...');
                setTimeout(loadHistoricalData, 1000);
                return;
            }

            console.log('[CHARTS] Requesting historical data (last 1 hour)...');
            wsClient.send({
                command: 'get_historical_data',
                connection_type: null, // null = all services
                hours: 1
            });
        }

        // PHASE 2 REFACTORING (2025-10-23): Use ChartManager for historical data
        function populateChartsWithHistoricalData(data) {
            if (chartManager && data && Array.isArray(data)) {
                chartManager.populateChartsWithEvents(data);
            }
        }

        // PHASE 2 REFACTORING (2025-10-23): Use ChartManager for chart updates
        function bufferEventForCharts(event) {
            if (chartManager) {
                chartManager.addEventToBuffer(event);
            }
        }

        // PHASE 2 REFACTORING (2025-10-23): Initialize with new modular architecture
        document.addEventListener('DOMContentLoaded', function() {
            console.log('[INIT] DOM loaded, starting initialization...');

            // Verify Chart.js is loaded
            console.log('[INIT] Chart.js loaded:', typeof Chart !== 'undefined');

            // Verify canvas elements exist
            const canvasCheck = {
                events: !!document.getElementById('eventsChart'),
                response: !!document.getElementById('responseChart'),
                throughput: !!document.getElementById('throughputChart'),
                error: !!document.getElementById('errorChart')
            };
            console.log('[INIT] Canvas elements exist:', canvasCheck);

            // PHASE 2: Initialize dashboard core
            dashboard = new DashboardCore();

            // PHASE 2: Initialize session tracker
            sessionTracker = new SessionTracker();

            // Setup event listeners for dashboard state changes
            dashboard.on('event:added', renderEvents);
            dashboard.on('stats:updated', ({ service, stats }) => {
                updateStats(service, stats);
            });
            dashboard.on('health:updated', () => {
                updateHealthBar();
            });

            // Sync legacy events array with dashboard state
            dashboard.on('event:added', (event) => {
                events = dashboard.state.events;
            });
            dashboard.on('events:cleared', () => {
                events = [];
                renderEvents();
            });

            // Sync legacy statsData with dashboard state
            dashboard.on('stats:updated', () => {
                statsData = dashboard.state.statsData;
            });

            initializeCharts();
            initializeWebSocket();
        });
    </script>
</body>
</html>

