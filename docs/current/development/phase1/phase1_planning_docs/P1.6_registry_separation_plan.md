# Phase 1.6: Provider Registry Separation Plan

**Target**: `src/providers/registry.py` (1,037 lines)  
**Goal**: Split into 3 focused modules (~300-400 lines each)  
**Status**: Planning

---

## Current Structure Analysis

### Overview
The file contains:
- **Helper functions** (14 functions, ~122 lines) - Feature flags and utilities
- **HealthWrappedProvider class** (1 class, ~120 lines) - Health monitoring wrapper
- **ModelProviderRegistry class** (1 class, ~650 lines) - Main registry with 20+ methods
- **ProviderDiagnostics class** (1 class, ~130 lines) - Diagnostics utilities

### Detailed Breakdown

#### Lines 1-122: Module Header & Helper Functions (122 lines)
- Module docstring and imports
- `.env` loading logic
- Feature flag functions (14 functions):
  - `_health_enabled()`, `_cb_enabled()`, `_health_log_only()`
  - `_retry_attempts()`, `_backoff_base()`, `_backoff_max()`
  - `_free_tier_enabled()`, `_free_model_list()`, `_apply_free_first()`
  - `_cost_aware_enabled()`, `_load_model_costs()`, `_max_cost_per_request()`, `_apply_cost_aware()`
  - `_get_health_manager()`

#### Lines 123-243: HealthWrappedProvider Class (120 lines)
- Wrapper class for health monitoring
- Methods:
  - `__init__()`, `get_provider_type()`, `get_model_configurations()`
  - `get_all_model_aliases()`, `list_all_known_models()`, `get_preferred_model()`
  - `get_provider_type_raw()`, `_schedule()`, `get_capabilities()`
  - `validate_model_name()`, `list_models()`, `supports_thinking_mode()`
  - `count_tokens()`, `generate_content()`

#### Lines 245-904: ModelProviderRegistry Class (659 lines)
- Main registry class with 20+ methods
- **Provider Management** (5 methods, ~200 lines):
  - `__new__()` - Singleton pattern
  - `register_provider()` - Register provider class
  - `get_provider()` - Get initialized provider (large method ~100 lines)
  - `get_provider_for_model()` - Get provider for model name (~50 lines)
  - `_get_api_key_for_provider()` - Get API key from env

- **Model Discovery** (5 methods, ~150 lines):
  - `get_available_providers()` - List registered providers
  - `get_available_models()` - Get all available models (~50 lines)
  - `get_available_model_names()` - Get model names
  - `list_available_models()` - Backward compatibility alias
  - `get_available_providers_with_keys()` - Providers with valid keys

- **Model Selection** (5 methods, ~200 lines):
  - `get_preferred_fallback_model()` - Select fallback model (~60 lines)
  - `get_kimi_provider()` - Get Kimi provider
  - `get_glm_provider()` - Get GLM provider
  - `get_best_provider_for_category()` - Best provider for category (~35 lines)
  - `_get_allowed_models_for_provider()` - Filter allowed models (~30 lines)

- **Fallback Chain** (2 methods, ~150 lines):
  - `_auggie_fallback_chain()` - Auggie-specific fallback (~90 lines)
  - `call_with_fallback()` - Generic fallback with retry (~60 lines)

- **Telemetry** (3 methods, ~50 lines):
  - `record_telemetry()` - Record usage metrics (~35 lines)
  - `get_telemetry()` - Get telemetry data
  - `clear_telemetry()` - Clear telemetry

#### Lines 905-1037: ProviderDiagnostics Class (132 lines)
- Diagnostics utilities
- Methods:
  - `_first_present()` - Find first present env var
  - `_is_placeholder()` - Check if value is placeholder
  - `diagnose_provider()` - Diagnose single provider (~55 lines)
  - `diagnose_all()` - Diagnose all providers
  - `diagnose_all_daemon_first()` - Prefer daemon snapshot

---

## Proposed 3-Module Split

### Module 1: `registry_config.py` (~200 lines)
**Purpose**: Configuration, feature flags, and utilities

**Contents**:
- Module docstring and imports
- `.env` loading logic
- All 14 feature flag functions
- `_get_health_manager()` function
- `HealthWrappedProvider` class (120 lines)

**Lines**: ~200  
**Responsibility**: Configuration management and health monitoring

---

### Module 2: `registry_core.py` (~450 lines)
**Purpose**: Core registry functionality

**Contents**:
- `ModelProviderRegistry` class with core methods:
  - Singleton pattern (`__new__`)
  - Provider management (register, get, get_for_model, get_api_key)
  - Model discovery (available providers, models, model names)
  - Helper methods (get_kimi_provider, get_glm_provider)
  - Telemetry (record, get, clear)

**Lines**: ~450  
**Responsibility**: Provider registration, initialization, and discovery

---

### Module 3: `registry_selection.py` (~350 lines)
**Purpose**: Model selection and fallback logic

**Contents**:
- Model selection methods from ModelProviderRegistry:
  - `get_preferred_fallback_model()` - Fallback model selection
  - `get_best_provider_for_category()` - Category-based selection
  - `_get_allowed_models_for_provider()` - Model filtering
  - `_auggie_fallback_chain()` - Auggie fallback chain
  - `call_with_fallback()` - Generic fallback with retry
- `ProviderDiagnostics` class (132 lines)

**Lines**: ~350  
**Responsibility**: Model selection, fallback chains, and diagnostics

---

## Refactored registry.py (~100 lines)

**Purpose**: Public API and backward compatibility

**Structure**:
```python
"""Model provider registry for managing available providers."""

# Re-export configuration and utilities
from src.providers.registry_config import (
    HealthWrappedProvider,
    _health_enabled,
    _cb_enabled,
    # ... other feature flags
)

# Re-export core registry
from src.providers.registry_core import ModelProviderRegistry

# Re-export selection and diagnostics
from src.providers.registry_selection import ProviderDiagnostics

__all__ = [
    "ModelProviderRegistry",
    "HealthWrappedProvider",
    "ProviderDiagnostics",
    # ... other exports
]
```

**Lines**: ~100  
**Responsibility**: Public API and backward compatibility

---

## Migration Strategy

1. **Create Module 1** (registry_config.py):
   - Extract .env loading logic
   - Extract all feature flag functions
   - Extract HealthWrappedProvider class
   - Extract _get_health_manager()

2. **Create Module 2** (registry_core.py):
   - Extract ModelProviderRegistry class skeleton
   - Extract provider management methods
   - Extract model discovery methods
   - Extract helper methods (get_kimi_provider, get_glm_provider)
   - Extract telemetry methods
   - Import config from Module 1

3. **Create Module 3** (registry_selection.py):
   - Extract model selection methods from ModelProviderRegistry
   - Extract fallback chain methods
   - Extract ProviderDiagnostics class
   - Import core from Module 2

4. **Refactor registry.py**:
   - Import all modules
   - Re-export public APIs
   - Maintain backward compatibility
   - Add __all__ for explicit exports

5. **Test & Validate**:
   - Run diagnostics on all files
   - Restart server
   - Test provider initialization
   - Test model selection
   - Verify fallback chains work

---

## Dependencies to Handle

- `logging`, `os`, `threading`, `typing`
- `pathlib`, `dotenv`
- `.base` (ModelProvider, ProviderType)
- `tools.models` (ToolModelCategory)
- `utils.health` (HealthManager, CircuitState)
- `asyncio`, `time`

---

## Acceptance Criteria

- ✅ All modules under 500 lines
- ✅ Clean separation of concerns
- ✅ No duplicate code
- ✅ Backward compatibility maintained
- ✅ All provider features work
- ✅ Model selection works correctly
- ✅ Fallback chains work correctly
- ✅ Server restarts successfully
- ✅ Zero breaking changes

---

**Next Steps**: Begin implementation with Module 1 (registry_config.py)

